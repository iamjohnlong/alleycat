{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///router.js","webpack:///webpack/bootstrap a5bbac2e1e544e66e24e","webpack:///./src/router.js","webpack:///./node_modules/url-pattern/lib/url-pattern.js","webpack:///(webpack)/buildin/amd-options.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","_typeof","Symbol","iterator","obj","constructor","_extends","assign","target","arguments","length","source","key","_urlPattern","_urlPattern2","default","routes","curLoc","args","didMount","noop","hooks","onMatch","notFound","router","loc","h","notFoundFn","keys","map","route","pattern","match","location","pathname","set","window","history","pushState","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","next","done","found","params","path","matched","err","return","middleware","f","render","fn","after","ret","onChange","onhashchange","onpopstate","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","slice","apply","UrlPattern","P","astNodeContainsSegmentsForProvidedParams","astNodeToNames","astNodeToRegexString","baseAstNodeToRegexString","concatMap","defaultOptions","escapeForRegex","getParam","keysAndValuesToObject","newParser","regexGroupCount","stringConcatMap","stringify","string","replace","array","results","concat","result","regex","RegExp","toString","exec","values","Array","isArray","push","Result","rest","Tagged","tag","parser","input","tagged","matches","sequence","parsers","pick","indexes","lazy","cached","baseMany","end","stringResult","atLeastOneResultRequired","parserResult","many1","concatMany1Till","firstChoice","options","U","wildcard","wildcardChar","optional","optionalSegmentStartChar","optionalSegmentEndChar","segmentNameCharset","named","segmentNameStartChar","escapedChar","escapeChar","token","segmentValueCharset","astNode","node","nextIndexes","sideEffects","index","maxIndex","Error","arg1","arg2","groupCount","parsed","isRegex","ast","names","TypeError","url","groups","__webpack_amd_options__"],"mappings":"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","file":"router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _urlPattern = __webpack_require__(1);\n\nvar _urlPattern2 = _interopRequireDefault(_urlPattern);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar routes = void 0;\nvar curLoc = void 0;\nvar args = void 0;\nvar didMount = void 0;\nvar noop = function noop() {};\nvar hooks = {\n  didMount: noop,\n  onMatch: noop,\n  notFound: noop\n};\n\nvar router = function router(loc, c, h, notFoundFn) {\n  didMount = false;\n  curLoc = loc;\n  routes = Object.keys(c).map(function (route) {\n    c[route].pattern = new _urlPattern2.default(route);\n    return c[route];\n  });\n  Object.assign(hooks, h);\n  match(location.pathname);\n};\n\nrouter.set = function (loc) {\n  if (curLoc === loc) return;\n  window.history.pushState(null, null, loc);\n  if (didMount) match(loc);\n};\n\nrouter.get = function () {\n  return args;\n};\n\n/**\n * @param {string} loc\n */\nvar match = function match(loc) {\n  curLoc = loc;\n  var notFound = true;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var route = _step.value;\n\n      var found = route.pattern.match(curLoc);\n      args = _extends({ params: found, path: curLoc, name: route.name }, route);\n      if (!didMount && found !== null) {\n        didMount = true;\n        hooks.didMount.call(null, args);\n      }\n      if (found !== null) {\n        matched(route, args);\n        notFound = false;\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (notFound) {\n    didMount = true;\n    hooks.didMount.call(null, args);\n    hooks.notFound();\n  }\n};\n\n/**\n * @param {object} route\n * @param {object} args\n */\nvar matched = function matched(route, args) {\n  var i = 0;\n  var next = function next() {\n    if (route.middleware.length !== i) {\n      var f = route.middleware[i];\n      i++;\n      f.call(null, args, next);\n    } else {\n      done(route.render, args);\n    }\n  };\n  route.middleware && route.middleware.length ? next() : done(route.render, args, true);\n};\n\nvar done = function done(fn, args, after) {\n  var ret = fn ? (typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === 'object' ? fn : fn.call(null, args) : undefined;\n  if (args.after) args.after(args);\n  if (after) hooks.onMatch(args, ret);\n};\n\nvar onChange = function onChange() {\n  match(location.pathname);\n};\n\nwindow.onhashchange = window.onpopstate = onChange;\n\nexports.default = router;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === \"function\") && (__webpack_require__(2) != null)) {\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// router.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a5bbac2e1e544e66e24e","import UrlPattern from 'url-pattern';\n\nlet routes;\nlet curLoc;\nlet args;\nlet didMount;\nconst noop = () => {};\nconst hooks = {\n  didMount: noop,\n  onMatch: noop,\n  notFound: noop,\n};\n\nconst router = (loc, c, h, notFoundFn) => {\n  didMount = false;\n  curLoc = loc;\n  routes = Object.keys(c).map((route) => {\n    c[route].pattern = new UrlPattern(route);\n    return c[route];\n  });\n  Object.assign(hooks, h);\n  match(location.pathname);\n};\n\nrouter.set = (loc) => {\n  if (curLoc === loc) return;\n  window.history.pushState(null, null, loc);\n  if (didMount) match(loc);\n};\n\nrouter.get = () => args;\n\n/**\n * @param {string} loc\n */\nconst match = (loc) => {\n  curLoc = loc;\n  let notFound = true;\n  for (let route of routes) {\n    const found = route.pattern.match(curLoc);\n    args = {params: found, path: curLoc, name: route.name, ...route};\n    if (!didMount && found !== null) {\n      didMount = true;\n      hooks.didMount.call(null, args);\n    }\n    if (found !== null) {\n      matched(route, args);\n      notFound = false;\n      break;\n    }\n  }\n  if (notFound) {\n    didMount = true;\n    hooks.didMount.call(null, args);\n    hooks.notFound();\n  }\n};\n\n/**\n * @param {object} route\n * @param {object} args\n */\nconst matched = (route, args) => {\n  let i = 0;\n  const next = () => {\n    if (route.middleware.length !== i) {\n      const f = route.middleware[i];\n      i++;\n      f.call(null, args, next);\n    } else {\n      done(route.render, args);\n    }\n  };\n  (route.middleware && route.middleware.length) ? next() : done(route.render, args, true);\n}\n\nconst done = (fn, args, after) => {\n  const ret = fn ? (typeof fn === 'object') ? fn : fn.call(null, args) : undefined;\n  if (args.after) args.after(args)\n  if (after) hooks.onMatch(args, ret);\n}\n\nconst onChange = () => {\n  match(location.pathname);\n}\n\nwindow.onhashchange = window.onpopstate = onChange;\n\nexport default router;\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.js","// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === typeof define) && (define.amd != null)) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url-pattern/lib/url-pattern.js\n// module id = 1\n// module chunks = 0","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}